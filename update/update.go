package main

import (
    "encoding/json"
    "fmt"
    "io"
    "io/ioutil"
    "os"
    "strings"
)

type Arg struct {
    Command  string
    Name     interface{}
    Type     interface{}
    Enum     interface{}
    Multiple bool
    Optional bool
}

type Command struct {
    Summary   string
    Arguments []Arg
    Group     string
    Since     string
}

func newCommand(name string, c *Command) string {
    var src string
    src += `   "` + name + `": {`
    src += `"` + name + `"`
    src += `, "` + c.Summary + `"`
    src += `, "`

    for i, v := range c.Arguments {
        if i > 0 {
            src += " "
        }
        src += newArg(&v)
    }

    if len(c.Arguments) == 0 {
        src += `-`
    }

    src += `"`
    src += `, "` + c.Group + `"`
    src += `, "` + c.Since + `"`
    src += ", `" + findDesc(name) + "`"
    src += `},`

    return src
}

func newArg(a *Arg) string {
    var src string

    if a.Command != "" {
        src += a.Command + " "
    }

    if v, ok := a.Enum.([]interface{}); ok {
        for i, vv := range v {
            src += vv.(string)

            if i < len(v)-1 {
                src += "|"
            }
        }
    } else {
        switch v := a.Name.(type) {
        case []interface{}:
            for i, vv := range v {
                src += vv.(string)

                if i < len(v)-1 {
                    src += " "
                }
            }
        case string:
            src += v
        default:
            fmt.Fprintln(os.Stderr, "type not found")
        }
    }

    if a.Multiple {
        src = src + " [" + src + " ...]"
    }

    if a.Optional {
        src = `[` + src + `]`
    }
    return src
}

func createCommands(data *map[string]Command) {
    f, err := os.OpenFile("commands.go", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)

    if err != nil {
        fmt.Fprintf(os.Stderr, "error opening commands.go (%s)\n", err.Error())
        os.Exit(1)
    }

    io.WriteString(f, "package main\n\n")
    io.WriteString(f, "// This file is auto-generated by ./update \n\n")
    io.WriteString(f, "var Commands = map[string]Command {\n")

    for k, v := range *data {
        name := strings.ToLower(k)
        io.WriteString(f, newCommand(name, &v))
        io.WriteString(f, "\n")
    }

    io.WriteString(f, "}\n")
    f.Close()
}

func findDesc(name string) string {
    path := "redis-doc/commands/"
    suffix := ".md"

    buf, err := ioutil.ReadFile(path + name + suffix)

    if err != nil {
        fmt.Fprintf(os.Stderr, err.Error())
        return ""
    }
    s := strings.Replace(string(buf), "`", "'", -1)
    s = strings.Trim(s, " \r\n")
    return s
}

func main() {
    path := "redis-doc/commands.json"
    buf, err := ioutil.ReadFile(path)

    if err != nil {
        fmt.Fprintf(os.Stderr, "error reading commands.json\n")
        os.Exit(1)
    }

    var commands map[string]Command
    err = json.Unmarshal(buf, &commands)

    if err != nil {
        fmt.Fprint(os.Stderr, "json unmarshal error %s \n", err.Error())
        os.Exit(1)
    }

    createCommands(&commands)

    os.Exit(0)
}
